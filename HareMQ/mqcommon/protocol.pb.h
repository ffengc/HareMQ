// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "msg.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2eproto;
namespace hare_mq {
class basicAckRequest;
struct basicAckRequestDefaultTypeInternal;
extern basicAckRequestDefaultTypeInternal _basicAckRequest_default_instance_;
class basicCancelRequest;
struct basicCancelRequestDefaultTypeInternal;
extern basicCancelRequestDefaultTypeInternal _basicCancelRequest_default_instance_;
class basicCommonResponse;
struct basicCommonResponseDefaultTypeInternal;
extern basicCommonResponseDefaultTypeInternal _basicCommonResponse_default_instance_;
class basicConsumeRequest;
struct basicConsumeRequestDefaultTypeInternal;
extern basicConsumeRequestDefaultTypeInternal _basicConsumeRequest_default_instance_;
class basicConsumeResponse;
struct basicConsumeResponseDefaultTypeInternal;
extern basicConsumeResponseDefaultTypeInternal _basicConsumeResponse_default_instance_;
class basicPublishRequest;
struct basicPublishRequestDefaultTypeInternal;
extern basicPublishRequestDefaultTypeInternal _basicPublishRequest_default_instance_;
class basicQueryRequest;
struct basicQueryRequestDefaultTypeInternal;
extern basicQueryRequestDefaultTypeInternal _basicQueryRequest_default_instance_;
class basicQueryResponse;
struct basicQueryResponseDefaultTypeInternal;
extern basicQueryResponseDefaultTypeInternal _basicQueryResponse_default_instance_;
class bindRequest;
struct bindRequestDefaultTypeInternal;
extern bindRequestDefaultTypeInternal _bindRequest_default_instance_;
class closeChannelRequest;
struct closeChannelRequestDefaultTypeInternal;
extern closeChannelRequestDefaultTypeInternal _closeChannelRequest_default_instance_;
class declareExchangeRequest;
struct declareExchangeRequestDefaultTypeInternal;
extern declareExchangeRequestDefaultTypeInternal _declareExchangeRequest_default_instance_;
class declareExchangeRequest_ArgsEntry_DoNotUse;
struct declareExchangeRequest_ArgsEntry_DoNotUseDefaultTypeInternal;
extern declareExchangeRequest_ArgsEntry_DoNotUseDefaultTypeInternal _declareExchangeRequest_ArgsEntry_DoNotUse_default_instance_;
class declareQueueRequest;
struct declareQueueRequestDefaultTypeInternal;
extern declareQueueRequestDefaultTypeInternal _declareQueueRequest_default_instance_;
class declareQueueRequest_ArgsEntry_DoNotUse;
struct declareQueueRequest_ArgsEntry_DoNotUseDefaultTypeInternal;
extern declareQueueRequest_ArgsEntry_DoNotUseDefaultTypeInternal _declareQueueRequest_ArgsEntry_DoNotUse_default_instance_;
class deleteExchangeRequest;
struct deleteExchangeRequestDefaultTypeInternal;
extern deleteExchangeRequestDefaultTypeInternal _deleteExchangeRequest_default_instance_;
class deleteQueueRequest;
struct deleteQueueRequestDefaultTypeInternal;
extern deleteQueueRequestDefaultTypeInternal _deleteQueueRequest_default_instance_;
class openChannelRequest;
struct openChannelRequestDefaultTypeInternal;
extern openChannelRequestDefaultTypeInternal _openChannelRequest_default_instance_;
class unbindRequest;
struct unbindRequestDefaultTypeInternal;
extern unbindRequestDefaultTypeInternal _unbindRequest_default_instance_;
}  // namespace hare_mq
PROTOBUF_NAMESPACE_OPEN
template<> ::hare_mq::basicAckRequest* Arena::CreateMaybeMessage<::hare_mq::basicAckRequest>(Arena*);
template<> ::hare_mq::basicCancelRequest* Arena::CreateMaybeMessage<::hare_mq::basicCancelRequest>(Arena*);
template<> ::hare_mq::basicCommonResponse* Arena::CreateMaybeMessage<::hare_mq::basicCommonResponse>(Arena*);
template<> ::hare_mq::basicConsumeRequest* Arena::CreateMaybeMessage<::hare_mq::basicConsumeRequest>(Arena*);
template<> ::hare_mq::basicConsumeResponse* Arena::CreateMaybeMessage<::hare_mq::basicConsumeResponse>(Arena*);
template<> ::hare_mq::basicPublishRequest* Arena::CreateMaybeMessage<::hare_mq::basicPublishRequest>(Arena*);
template<> ::hare_mq::basicQueryRequest* Arena::CreateMaybeMessage<::hare_mq::basicQueryRequest>(Arena*);
template<> ::hare_mq::basicQueryResponse* Arena::CreateMaybeMessage<::hare_mq::basicQueryResponse>(Arena*);
template<> ::hare_mq::bindRequest* Arena::CreateMaybeMessage<::hare_mq::bindRequest>(Arena*);
template<> ::hare_mq::closeChannelRequest* Arena::CreateMaybeMessage<::hare_mq::closeChannelRequest>(Arena*);
template<> ::hare_mq::declareExchangeRequest* Arena::CreateMaybeMessage<::hare_mq::declareExchangeRequest>(Arena*);
template<> ::hare_mq::declareExchangeRequest_ArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::hare_mq::declareExchangeRequest_ArgsEntry_DoNotUse>(Arena*);
template<> ::hare_mq::declareQueueRequest* Arena::CreateMaybeMessage<::hare_mq::declareQueueRequest>(Arena*);
template<> ::hare_mq::declareQueueRequest_ArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::hare_mq::declareQueueRequest_ArgsEntry_DoNotUse>(Arena*);
template<> ::hare_mq::deleteExchangeRequest* Arena::CreateMaybeMessage<::hare_mq::deleteExchangeRequest>(Arena*);
template<> ::hare_mq::deleteQueueRequest* Arena::CreateMaybeMessage<::hare_mq::deleteQueueRequest>(Arena*);
template<> ::hare_mq::openChannelRequest* Arena::CreateMaybeMessage<::hare_mq::openChannelRequest>(Arena*);
template<> ::hare_mq::unbindRequest* Arena::CreateMaybeMessage<::hare_mq::unbindRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hare_mq {

// ===================================================================

class openChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.openChannelRequest) */ {
 public:
  inline openChannelRequest() : openChannelRequest(nullptr) {}
  ~openChannelRequest() override;
  explicit PROTOBUF_CONSTEXPR openChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  openChannelRequest(const openChannelRequest& from);
  openChannelRequest(openChannelRequest&& from) noexcept
    : openChannelRequest() {
    *this = ::std::move(from);
  }

  inline openChannelRequest& operator=(const openChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline openChannelRequest& operator=(openChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const openChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const openChannelRequest* internal_default_instance() {
    return reinterpret_cast<const openChannelRequest*>(
               &_openChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(openChannelRequest& a, openChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(openChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(openChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  openChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<openChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const openChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const openChannelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(openChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.openChannelRequest";
  }
  protected:
  explicit openChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.openChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class closeChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.closeChannelRequest) */ {
 public:
  inline closeChannelRequest() : closeChannelRequest(nullptr) {}
  ~closeChannelRequest() override;
  explicit PROTOBUF_CONSTEXPR closeChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  closeChannelRequest(const closeChannelRequest& from);
  closeChannelRequest(closeChannelRequest&& from) noexcept
    : closeChannelRequest() {
    *this = ::std::move(from);
  }

  inline closeChannelRequest& operator=(const closeChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline closeChannelRequest& operator=(closeChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const closeChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const closeChannelRequest* internal_default_instance() {
    return reinterpret_cast<const closeChannelRequest*>(
               &_closeChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(closeChannelRequest& a, closeChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(closeChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(closeChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  closeChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<closeChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const closeChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const closeChannelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(closeChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.closeChannelRequest";
  }
  protected:
  explicit closeChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.closeChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class declareExchangeRequest_ArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<declareExchangeRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<declareExchangeRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  declareExchangeRequest_ArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR declareExchangeRequest_ArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit declareExchangeRequest_ArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const declareExchangeRequest_ArgsEntry_DoNotUse& other);
  static const declareExchangeRequest_ArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const declareExchangeRequest_ArgsEntry_DoNotUse*>(&_declareExchangeRequest_ArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hare_mq.declareExchangeRequest.ArgsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hare_mq.declareExchangeRequest.ArgsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protocol_2eproto;
};

// -------------------------------------------------------------------

class declareExchangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.declareExchangeRequest) */ {
 public:
  inline declareExchangeRequest() : declareExchangeRequest(nullptr) {}
  ~declareExchangeRequest() override;
  explicit PROTOBUF_CONSTEXPR declareExchangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  declareExchangeRequest(const declareExchangeRequest& from);
  declareExchangeRequest(declareExchangeRequest&& from) noexcept
    : declareExchangeRequest() {
    *this = ::std::move(from);
  }

  inline declareExchangeRequest& operator=(const declareExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline declareExchangeRequest& operator=(declareExchangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const declareExchangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const declareExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const declareExchangeRequest*>(
               &_declareExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(declareExchangeRequest& a, declareExchangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(declareExchangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(declareExchangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  declareExchangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<declareExchangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const declareExchangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const declareExchangeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(declareExchangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.declareExchangeRequest";
  }
  protected:
  explicit declareExchangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 7,
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
    kExchangeTypeFieldNumber = 4,
    kDurableFieldNumber = 5,
    kAutoDeleteFieldNumber = 6,
  };
  // map<string, string> args = 7;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_args();

  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // .hare_mq.ExchangeType exchange_type = 4;
  void clear_exchange_type();
  ::hare_mq::ExchangeType exchange_type() const;
  void set_exchange_type(::hare_mq::ExchangeType value);
  private:
  ::hare_mq::ExchangeType _internal_exchange_type() const;
  void _internal_set_exchange_type(::hare_mq::ExchangeType value);
  public:

  // bool durable = 5;
  void clear_durable();
  bool durable() const;
  void set_durable(bool value);
  private:
  bool _internal_durable() const;
  void _internal_set_durable(bool value);
  public:

  // bool auto_delete = 6;
  void clear_auto_delete();
  bool auto_delete() const;
  void set_auto_delete(bool value);
  private:
  bool _internal_auto_delete() const;
  void _internal_set_auto_delete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.declareExchangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      declareExchangeRequest_ArgsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
  int exchange_type_;
  bool durable_;
  bool auto_delete_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class deleteExchangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.deleteExchangeRequest) */ {
 public:
  inline deleteExchangeRequest() : deleteExchangeRequest(nullptr) {}
  ~deleteExchangeRequest() override;
  explicit PROTOBUF_CONSTEXPR deleteExchangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteExchangeRequest(const deleteExchangeRequest& from);
  deleteExchangeRequest(deleteExchangeRequest&& from) noexcept
    : deleteExchangeRequest() {
    *this = ::std::move(from);
  }

  inline deleteExchangeRequest& operator=(const deleteExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteExchangeRequest& operator=(deleteExchangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteExchangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const deleteExchangeRequest*>(
               &_deleteExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(deleteExchangeRequest& a, deleteExchangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteExchangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteExchangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteExchangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteExchangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteExchangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const deleteExchangeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteExchangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.deleteExchangeRequest";
  }
  protected:
  explicit deleteExchangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.deleteExchangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class declareQueueRequest_ArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<declareQueueRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<declareQueueRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  declareQueueRequest_ArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR declareQueueRequest_ArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit declareQueueRequest_ArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const declareQueueRequest_ArgsEntry_DoNotUse& other);
  static const declareQueueRequest_ArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const declareQueueRequest_ArgsEntry_DoNotUse*>(&_declareQueueRequest_ArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hare_mq.declareQueueRequest.ArgsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hare_mq.declareQueueRequest.ArgsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protocol_2eproto;
};

// -------------------------------------------------------------------

class declareQueueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.declareQueueRequest) */ {
 public:
  inline declareQueueRequest() : declareQueueRequest(nullptr) {}
  ~declareQueueRequest() override;
  explicit PROTOBUF_CONSTEXPR declareQueueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  declareQueueRequest(const declareQueueRequest& from);
  declareQueueRequest(declareQueueRequest&& from) noexcept
    : declareQueueRequest() {
    *this = ::std::move(from);
  }

  inline declareQueueRequest& operator=(const declareQueueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline declareQueueRequest& operator=(declareQueueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const declareQueueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const declareQueueRequest* internal_default_instance() {
    return reinterpret_cast<const declareQueueRequest*>(
               &_declareQueueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(declareQueueRequest& a, declareQueueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(declareQueueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(declareQueueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  declareQueueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<declareQueueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const declareQueueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const declareQueueRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(declareQueueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.declareQueueRequest";
  }
  protected:
  explicit declareQueueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 7,
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kQueueNameFieldNumber = 3,
    kExclusiveFieldNumber = 4,
    kDurableFieldNumber = 5,
    kAutoDeleteFieldNumber = 6,
  };
  // map<string, string> args = 7;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_args();

  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string queue_name = 3;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // bool exclusive = 4;
  void clear_exclusive();
  bool exclusive() const;
  void set_exclusive(bool value);
  private:
  bool _internal_exclusive() const;
  void _internal_set_exclusive(bool value);
  public:

  // bool durable = 5;
  void clear_durable();
  bool durable() const;
  void set_durable(bool value);
  private:
  bool _internal_durable() const;
  void _internal_set_durable(bool value);
  public:

  // bool auto_delete = 6;
  void clear_auto_delete();
  bool auto_delete() const;
  void set_auto_delete(bool value);
  private:
  bool _internal_auto_delete() const;
  void _internal_set_auto_delete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.declareQueueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      declareQueueRequest_ArgsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
  bool exclusive_;
  bool durable_;
  bool auto_delete_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class deleteQueueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.deleteQueueRequest) */ {
 public:
  inline deleteQueueRequest() : deleteQueueRequest(nullptr) {}
  ~deleteQueueRequest() override;
  explicit PROTOBUF_CONSTEXPR deleteQueueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteQueueRequest(const deleteQueueRequest& from);
  deleteQueueRequest(deleteQueueRequest&& from) noexcept
    : deleteQueueRequest() {
    *this = ::std::move(from);
  }

  inline deleteQueueRequest& operator=(const deleteQueueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteQueueRequest& operator=(deleteQueueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteQueueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteQueueRequest* internal_default_instance() {
    return reinterpret_cast<const deleteQueueRequest*>(
               &_deleteQueueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(deleteQueueRequest& a, deleteQueueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteQueueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteQueueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteQueueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteQueueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteQueueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const deleteQueueRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteQueueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.deleteQueueRequest";
  }
  protected:
  explicit deleteQueueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kQueueNameFieldNumber = 3,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string queue_name = 3;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.deleteQueueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class bindRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.bindRequest) */ {
 public:
  inline bindRequest() : bindRequest(nullptr) {}
  ~bindRequest() override;
  explicit PROTOBUF_CONSTEXPR bindRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  bindRequest(const bindRequest& from);
  bindRequest(bindRequest&& from) noexcept
    : bindRequest() {
    *this = ::std::move(from);
  }

  inline bindRequest& operator=(const bindRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline bindRequest& operator=(bindRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const bindRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const bindRequest* internal_default_instance() {
    return reinterpret_cast<const bindRequest*>(
               &_bindRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(bindRequest& a, bindRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(bindRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(bindRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  bindRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<bindRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const bindRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const bindRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bindRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.bindRequest";
  }
  protected:
  explicit bindRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
    kQueueNameFieldNumber = 4,
    kBindingKeyFieldNumber = 5,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // string queue_name = 4;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // string binding_key = 5;
  void clear_binding_key();
  const std::string& binding_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binding_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binding_key();
  PROTOBUF_NODISCARD std::string* release_binding_key();
  void set_allocated_binding_key(std::string* binding_key);
  private:
  const std::string& _internal_binding_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binding_key(const std::string& value);
  std::string* _internal_mutable_binding_key();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.bindRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binding_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class unbindRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.unbindRequest) */ {
 public:
  inline unbindRequest() : unbindRequest(nullptr) {}
  ~unbindRequest() override;
  explicit PROTOBUF_CONSTEXPR unbindRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  unbindRequest(const unbindRequest& from);
  unbindRequest(unbindRequest&& from) noexcept
    : unbindRequest() {
    *this = ::std::move(from);
  }

  inline unbindRequest& operator=(const unbindRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline unbindRequest& operator=(unbindRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const unbindRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const unbindRequest* internal_default_instance() {
    return reinterpret_cast<const unbindRequest*>(
               &_unbindRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(unbindRequest& a, unbindRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(unbindRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(unbindRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  unbindRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<unbindRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const unbindRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const unbindRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(unbindRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.unbindRequest";
  }
  protected:
  explicit unbindRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
    kQueueNameFieldNumber = 4,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // string queue_name = 4;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.unbindRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicPublishRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.basicPublishRequest) */ {
 public:
  inline basicPublishRequest() : basicPublishRequest(nullptr) {}
  ~basicPublishRequest() override;
  explicit PROTOBUF_CONSTEXPR basicPublishRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicPublishRequest(const basicPublishRequest& from);
  basicPublishRequest(basicPublishRequest&& from) noexcept
    : basicPublishRequest() {
    *this = ::std::move(from);
  }

  inline basicPublishRequest& operator=(const basicPublishRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicPublishRequest& operator=(basicPublishRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicPublishRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicPublishRequest* internal_default_instance() {
    return reinterpret_cast<const basicPublishRequest*>(
               &_basicPublishRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(basicPublishRequest& a, basicPublishRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(basicPublishRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicPublishRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicPublishRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicPublishRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicPublishRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const basicPublishRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicPublishRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.basicPublishRequest";
  }
  protected:
  explicit basicPublishRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kExchangeNameFieldNumber = 3,
    kBodyFieldNumber = 4,
    kPropertiesFieldNumber = 5,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string exchange_name = 3;
  void clear_exchange_name();
  const std::string& exchange_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_name();
  PROTOBUF_NODISCARD std::string* release_exchange_name();
  void set_allocated_exchange_name(std::string* exchange_name);
  private:
  const std::string& _internal_exchange_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_name(const std::string& value);
  std::string* _internal_mutable_exchange_name();
  public:

  // string body = 4;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // .hare_mq.BasicProperties properties = 5;
  bool has_properties() const;
  private:
  bool _internal_has_properties() const;
  public:
  void clear_properties();
  const ::hare_mq::BasicProperties& properties() const;
  PROTOBUF_NODISCARD ::hare_mq::BasicProperties* release_properties();
  ::hare_mq::BasicProperties* mutable_properties();
  void set_allocated_properties(::hare_mq::BasicProperties* properties);
  private:
  const ::hare_mq::BasicProperties& _internal_properties() const;
  ::hare_mq::BasicProperties* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::hare_mq::BasicProperties* properties);
  ::hare_mq::BasicProperties* unsafe_arena_release_properties();

  // @@protoc_insertion_point(class_scope:hare_mq.basicPublishRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  ::hare_mq::BasicProperties* properties_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicAckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.basicAckRequest) */ {
 public:
  inline basicAckRequest() : basicAckRequest(nullptr) {}
  ~basicAckRequest() override;
  explicit PROTOBUF_CONSTEXPR basicAckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicAckRequest(const basicAckRequest& from);
  basicAckRequest(basicAckRequest&& from) noexcept
    : basicAckRequest() {
    *this = ::std::move(from);
  }

  inline basicAckRequest& operator=(const basicAckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicAckRequest& operator=(basicAckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicAckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicAckRequest* internal_default_instance() {
    return reinterpret_cast<const basicAckRequest*>(
               &_basicAckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(basicAckRequest& a, basicAckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(basicAckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicAckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicAckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicAckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicAckRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const basicAckRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicAckRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.basicAckRequest";
  }
  protected:
  explicit basicAckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kQueueNameFieldNumber = 3,
    kMessageIdFieldNumber = 4,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string queue_name = 3;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // string message_id = 4;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.basicAckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicConsumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.basicConsumeRequest) */ {
 public:
  inline basicConsumeRequest() : basicConsumeRequest(nullptr) {}
  ~basicConsumeRequest() override;
  explicit PROTOBUF_CONSTEXPR basicConsumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicConsumeRequest(const basicConsumeRequest& from);
  basicConsumeRequest(basicConsumeRequest&& from) noexcept
    : basicConsumeRequest() {
    *this = ::std::move(from);
  }

  inline basicConsumeRequest& operator=(const basicConsumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicConsumeRequest& operator=(basicConsumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicConsumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicConsumeRequest* internal_default_instance() {
    return reinterpret_cast<const basicConsumeRequest*>(
               &_basicConsumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(basicConsumeRequest& a, basicConsumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(basicConsumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicConsumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicConsumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicConsumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicConsumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const basicConsumeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicConsumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.basicConsumeRequest";
  }
  protected:
  explicit basicConsumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kConsumerTagFieldNumber = 3,
    kQueueNameFieldNumber = 4,
    kAutoAckFieldNumber = 5,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string consumer_tag = 3;
  void clear_consumer_tag();
  const std::string& consumer_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consumer_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consumer_tag();
  PROTOBUF_NODISCARD std::string* release_consumer_tag();
  void set_allocated_consumer_tag(std::string* consumer_tag);
  private:
  const std::string& _internal_consumer_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumer_tag(const std::string& value);
  std::string* _internal_mutable_consumer_tag();
  public:

  // string queue_name = 4;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // bool auto_ack = 5;
  void clear_auto_ack();
  bool auto_ack() const;
  void set_auto_ack(bool value);
  private:
  bool _internal_auto_ack() const;
  void _internal_set_auto_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.basicConsumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consumer_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
  bool auto_ack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicCancelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.basicCancelRequest) */ {
 public:
  inline basicCancelRequest() : basicCancelRequest(nullptr) {}
  ~basicCancelRequest() override;
  explicit PROTOBUF_CONSTEXPR basicCancelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicCancelRequest(const basicCancelRequest& from);
  basicCancelRequest(basicCancelRequest&& from) noexcept
    : basicCancelRequest() {
    *this = ::std::move(from);
  }

  inline basicCancelRequest& operator=(const basicCancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicCancelRequest& operator=(basicCancelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicCancelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicCancelRequest* internal_default_instance() {
    return reinterpret_cast<const basicCancelRequest*>(
               &_basicCancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(basicCancelRequest& a, basicCancelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(basicCancelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicCancelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicCancelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicCancelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicCancelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const basicCancelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicCancelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.basicCancelRequest";
  }
  protected:
  explicit basicCancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kConsumerTagFieldNumber = 3,
    kQueueNameFieldNumber = 4,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string consumer_tag = 3;
  void clear_consumer_tag();
  const std::string& consumer_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consumer_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consumer_tag();
  PROTOBUF_NODISCARD std::string* release_consumer_tag();
  void set_allocated_consumer_tag(std::string* consumer_tag);
  private:
  const std::string& _internal_consumer_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumer_tag(const std::string& value);
  std::string* _internal_mutable_consumer_tag();
  public:

  // string queue_name = 4;
  void clear_queue_name();
  const std::string& queue_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queue_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* queue_name);
  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(const std::string& value);
  std::string* _internal_mutable_queue_name();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.basicCancelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consumer_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicConsumeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.basicConsumeResponse) */ {
 public:
  inline basicConsumeResponse() : basicConsumeResponse(nullptr) {}
  ~basicConsumeResponse() override;
  explicit PROTOBUF_CONSTEXPR basicConsumeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicConsumeResponse(const basicConsumeResponse& from);
  basicConsumeResponse(basicConsumeResponse&& from) noexcept
    : basicConsumeResponse() {
    *this = ::std::move(from);
  }

  inline basicConsumeResponse& operator=(const basicConsumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicConsumeResponse& operator=(basicConsumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicConsumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicConsumeResponse* internal_default_instance() {
    return reinterpret_cast<const basicConsumeResponse*>(
               &_basicConsumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(basicConsumeResponse& a, basicConsumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(basicConsumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicConsumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicConsumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicConsumeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicConsumeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const basicConsumeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicConsumeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.basicConsumeResponse";
  }
  protected:
  explicit basicConsumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCidFieldNumber = 1,
    kConsumerTagFieldNumber = 2,
    kBodyFieldNumber = 3,
    kPropertiesFieldNumber = 4,
  };
  // string cid = 1;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string consumer_tag = 2;
  void clear_consumer_tag();
  const std::string& consumer_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consumer_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consumer_tag();
  PROTOBUF_NODISCARD std::string* release_consumer_tag();
  void set_allocated_consumer_tag(std::string* consumer_tag);
  private:
  const std::string& _internal_consumer_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumer_tag(const std::string& value);
  std::string* _internal_mutable_consumer_tag();
  public:

  // string body = 3;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // .hare_mq.BasicProperties properties = 4;
  bool has_properties() const;
  private:
  bool _internal_has_properties() const;
  public:
  void clear_properties();
  const ::hare_mq::BasicProperties& properties() const;
  PROTOBUF_NODISCARD ::hare_mq::BasicProperties* release_properties();
  ::hare_mq::BasicProperties* mutable_properties();
  void set_allocated_properties(::hare_mq::BasicProperties* properties);
  private:
  const ::hare_mq::BasicProperties& _internal_properties() const;
  ::hare_mq::BasicProperties* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::hare_mq::BasicProperties* properties);
  ::hare_mq::BasicProperties* unsafe_arena_release_properties();

  // @@protoc_insertion_point(class_scope:hare_mq.basicConsumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consumer_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  ::hare_mq::BasicProperties* properties_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicCommonResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.basicCommonResponse) */ {
 public:
  inline basicCommonResponse() : basicCommonResponse(nullptr) {}
  ~basicCommonResponse() override;
  explicit PROTOBUF_CONSTEXPR basicCommonResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicCommonResponse(const basicCommonResponse& from);
  basicCommonResponse(basicCommonResponse&& from) noexcept
    : basicCommonResponse() {
    *this = ::std::move(from);
  }

  inline basicCommonResponse& operator=(const basicCommonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicCommonResponse& operator=(basicCommonResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicCommonResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicCommonResponse* internal_default_instance() {
    return reinterpret_cast<const basicCommonResponse*>(
               &_basicCommonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(basicCommonResponse& a, basicCommonResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(basicCommonResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicCommonResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicCommonResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicCommonResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicCommonResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const basicCommonResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicCommonResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.basicCommonResponse";
  }
  protected:
  explicit basicCommonResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kOkFieldNumber = 3,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // bool ok = 3;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.basicCommonResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicQueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.basicQueryRequest) */ {
 public:
  inline basicQueryRequest() : basicQueryRequest(nullptr) {}
  ~basicQueryRequest() override;
  explicit PROTOBUF_CONSTEXPR basicQueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicQueryRequest(const basicQueryRequest& from);
  basicQueryRequest(basicQueryRequest&& from) noexcept
    : basicQueryRequest() {
    *this = ::std::move(from);
  }

  inline basicQueryRequest& operator=(const basicQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicQueryRequest& operator=(basicQueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicQueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicQueryRequest* internal_default_instance() {
    return reinterpret_cast<const basicQueryRequest*>(
               &_basicQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(basicQueryRequest& a, basicQueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(basicQueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicQueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicQueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicQueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicQueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const basicQueryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicQueryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.basicQueryRequest";
  }
  protected:
  explicit basicQueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.basicQueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class basicQueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hare_mq.basicQueryResponse) */ {
 public:
  inline basicQueryResponse() : basicQueryResponse(nullptr) {}
  ~basicQueryResponse() override;
  explicit PROTOBUF_CONSTEXPR basicQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  basicQueryResponse(const basicQueryResponse& from);
  basicQueryResponse(basicQueryResponse&& from) noexcept
    : basicQueryResponse() {
    *this = ::std::move(from);
  }

  inline basicQueryResponse& operator=(const basicQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline basicQueryResponse& operator=(basicQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const basicQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const basicQueryResponse* internal_default_instance() {
    return reinterpret_cast<const basicQueryResponse*>(
               &_basicQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(basicQueryResponse& a, basicQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(basicQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(basicQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  basicQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<basicQueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const basicQueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const basicQueryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(basicQueryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hare_mq.basicQueryResponse";
  }
  protected:
  explicit basicQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 1,
    kCidFieldNumber = 2,
    kBodyFieldNumber = 3,
  };
  // string rid = 1;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string body = 3;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // @@protoc_insertion_point(class_scope:hare_mq.basicQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// openChannelRequest

// string rid = 1;
inline void openChannelRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& openChannelRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.openChannelRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void openChannelRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.openChannelRequest.rid)
}
inline std::string* openChannelRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.openChannelRequest.rid)
  return _s;
}
inline const std::string& openChannelRequest::_internal_rid() const {
  return rid_.Get();
}
inline void openChannelRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* openChannelRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* openChannelRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.openChannelRequest.rid)
  return rid_.Release();
}
inline void openChannelRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.openChannelRequest.rid)
}

// string cid = 2;
inline void openChannelRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& openChannelRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.openChannelRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void openChannelRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.openChannelRequest.cid)
}
inline std::string* openChannelRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.openChannelRequest.cid)
  return _s;
}
inline const std::string& openChannelRequest::_internal_cid() const {
  return cid_.Get();
}
inline void openChannelRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* openChannelRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* openChannelRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.openChannelRequest.cid)
  return cid_.Release();
}
inline void openChannelRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.openChannelRequest.cid)
}

// -------------------------------------------------------------------

// closeChannelRequest

// string rid = 1;
inline void closeChannelRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& closeChannelRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.closeChannelRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void closeChannelRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.closeChannelRequest.rid)
}
inline std::string* closeChannelRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.closeChannelRequest.rid)
  return _s;
}
inline const std::string& closeChannelRequest::_internal_rid() const {
  return rid_.Get();
}
inline void closeChannelRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* closeChannelRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* closeChannelRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.closeChannelRequest.rid)
  return rid_.Release();
}
inline void closeChannelRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.closeChannelRequest.rid)
}

// string cid = 2;
inline void closeChannelRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& closeChannelRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.closeChannelRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void closeChannelRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.closeChannelRequest.cid)
}
inline std::string* closeChannelRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.closeChannelRequest.cid)
  return _s;
}
inline const std::string& closeChannelRequest::_internal_cid() const {
  return cid_.Get();
}
inline void closeChannelRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* closeChannelRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* closeChannelRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.closeChannelRequest.cid)
  return cid_.Release();
}
inline void closeChannelRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.closeChannelRequest.cid)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// declareExchangeRequest

// string rid = 1;
inline void declareExchangeRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& declareExchangeRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareExchangeRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareExchangeRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.declareExchangeRequest.rid)
}
inline std::string* declareExchangeRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.declareExchangeRequest.rid)
  return _s;
}
inline const std::string& declareExchangeRequest::_internal_rid() const {
  return rid_.Get();
}
inline void declareExchangeRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.declareExchangeRequest.rid)
  return rid_.Release();
}
inline void declareExchangeRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.declareExchangeRequest.rid)
}

// string cid = 2;
inline void declareExchangeRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& declareExchangeRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareExchangeRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareExchangeRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.declareExchangeRequest.cid)
}
inline std::string* declareExchangeRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.declareExchangeRequest.cid)
  return _s;
}
inline const std::string& declareExchangeRequest::_internal_cid() const {
  return cid_.Get();
}
inline void declareExchangeRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.declareExchangeRequest.cid)
  return cid_.Release();
}
inline void declareExchangeRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.declareExchangeRequest.cid)
}

// string exchange_name = 3;
inline void declareExchangeRequest::clear_exchange_name() {
  exchange_name_.ClearToEmpty();
}
inline const std::string& declareExchangeRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareExchangeRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareExchangeRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.declareExchangeRequest.exchange_name)
}
inline std::string* declareExchangeRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.declareExchangeRequest.exchange_name)
  return _s;
}
inline const std::string& declareExchangeRequest::_internal_exchange_name() const {
  return exchange_name_.Get();
}
inline void declareExchangeRequest::_internal_set_exchange_name(const std::string& value) {
  
  exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::_internal_mutable_exchange_name() {
  
  return exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* declareExchangeRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:hare_mq.declareExchangeRequest.exchange_name)
  return exchange_name_.Release();
}
inline void declareExchangeRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (exchange_name_.IsDefault()) {
    exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.declareExchangeRequest.exchange_name)
}

// .hare_mq.ExchangeType exchange_type = 4;
inline void declareExchangeRequest::clear_exchange_type() {
  exchange_type_ = 0;
}
inline ::hare_mq::ExchangeType declareExchangeRequest::_internal_exchange_type() const {
  return static_cast< ::hare_mq::ExchangeType >(exchange_type_);
}
inline ::hare_mq::ExchangeType declareExchangeRequest::exchange_type() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareExchangeRequest.exchange_type)
  return _internal_exchange_type();
}
inline void declareExchangeRequest::_internal_set_exchange_type(::hare_mq::ExchangeType value) {
  
  exchange_type_ = value;
}
inline void declareExchangeRequest::set_exchange_type(::hare_mq::ExchangeType value) {
  _internal_set_exchange_type(value);
  // @@protoc_insertion_point(field_set:hare_mq.declareExchangeRequest.exchange_type)
}

// bool durable = 5;
inline void declareExchangeRequest::clear_durable() {
  durable_ = false;
}
inline bool declareExchangeRequest::_internal_durable() const {
  return durable_;
}
inline bool declareExchangeRequest::durable() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareExchangeRequest.durable)
  return _internal_durable();
}
inline void declareExchangeRequest::_internal_set_durable(bool value) {
  
  durable_ = value;
}
inline void declareExchangeRequest::set_durable(bool value) {
  _internal_set_durable(value);
  // @@protoc_insertion_point(field_set:hare_mq.declareExchangeRequest.durable)
}

// bool auto_delete = 6;
inline void declareExchangeRequest::clear_auto_delete() {
  auto_delete_ = false;
}
inline bool declareExchangeRequest::_internal_auto_delete() const {
  return auto_delete_;
}
inline bool declareExchangeRequest::auto_delete() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareExchangeRequest.auto_delete)
  return _internal_auto_delete();
}
inline void declareExchangeRequest::_internal_set_auto_delete(bool value) {
  
  auto_delete_ = value;
}
inline void declareExchangeRequest::set_auto_delete(bool value) {
  _internal_set_auto_delete(value);
  // @@protoc_insertion_point(field_set:hare_mq.declareExchangeRequest.auto_delete)
}

// map<string, string> args = 7;
inline int declareExchangeRequest::_internal_args_size() const {
  return args_.size();
}
inline int declareExchangeRequest::args_size() const {
  return _internal_args_size();
}
inline void declareExchangeRequest::clear_args() {
  args_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
declareExchangeRequest::_internal_args() const {
  return args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
declareExchangeRequest::args() const {
  // @@protoc_insertion_point(field_map:hare_mq.declareExchangeRequest.args)
  return _internal_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
declareExchangeRequest::_internal_mutable_args() {
  return args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
declareExchangeRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_map:hare_mq.declareExchangeRequest.args)
  return _internal_mutable_args();
}

// -------------------------------------------------------------------

// deleteExchangeRequest

// string rid = 1;
inline void deleteExchangeRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& deleteExchangeRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.deleteExchangeRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteExchangeRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.deleteExchangeRequest.rid)
}
inline std::string* deleteExchangeRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.deleteExchangeRequest.rid)
  return _s;
}
inline const std::string& deleteExchangeRequest::_internal_rid() const {
  return rid_.Get();
}
inline void deleteExchangeRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.deleteExchangeRequest.rid)
  return rid_.Release();
}
inline void deleteExchangeRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.deleteExchangeRequest.rid)
}

// string cid = 2;
inline void deleteExchangeRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& deleteExchangeRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.deleteExchangeRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteExchangeRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.deleteExchangeRequest.cid)
}
inline std::string* deleteExchangeRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.deleteExchangeRequest.cid)
  return _s;
}
inline const std::string& deleteExchangeRequest::_internal_cid() const {
  return cid_.Get();
}
inline void deleteExchangeRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.deleteExchangeRequest.cid)
  return cid_.Release();
}
inline void deleteExchangeRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.deleteExchangeRequest.cid)
}

// string exchange_name = 3;
inline void deleteExchangeRequest::clear_exchange_name() {
  exchange_name_.ClearToEmpty();
}
inline const std::string& deleteExchangeRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.deleteExchangeRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteExchangeRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.deleteExchangeRequest.exchange_name)
}
inline std::string* deleteExchangeRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.deleteExchangeRequest.exchange_name)
  return _s;
}
inline const std::string& deleteExchangeRequest::_internal_exchange_name() const {
  return exchange_name_.Get();
}
inline void deleteExchangeRequest::_internal_set_exchange_name(const std::string& value) {
  
  exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::_internal_mutable_exchange_name() {
  
  return exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteExchangeRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:hare_mq.deleteExchangeRequest.exchange_name)
  return exchange_name_.Release();
}
inline void deleteExchangeRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (exchange_name_.IsDefault()) {
    exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.deleteExchangeRequest.exchange_name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// declareQueueRequest

// string rid = 1;
inline void declareQueueRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& declareQueueRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareQueueRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareQueueRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.declareQueueRequest.rid)
}
inline std::string* declareQueueRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.declareQueueRequest.rid)
  return _s;
}
inline const std::string& declareQueueRequest::_internal_rid() const {
  return rid_.Get();
}
inline void declareQueueRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* declareQueueRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* declareQueueRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.declareQueueRequest.rid)
  return rid_.Release();
}
inline void declareQueueRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.declareQueueRequest.rid)
}

// string cid = 2;
inline void declareQueueRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& declareQueueRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareQueueRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareQueueRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.declareQueueRequest.cid)
}
inline std::string* declareQueueRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.declareQueueRequest.cid)
  return _s;
}
inline const std::string& declareQueueRequest::_internal_cid() const {
  return cid_.Get();
}
inline void declareQueueRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* declareQueueRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* declareQueueRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.declareQueueRequest.cid)
  return cid_.Release();
}
inline void declareQueueRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.declareQueueRequest.cid)
}

// string queue_name = 3;
inline void declareQueueRequest::clear_queue_name() {
  queue_name_.ClearToEmpty();
}
inline const std::string& declareQueueRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareQueueRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void declareQueueRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.declareQueueRequest.queue_name)
}
inline std::string* declareQueueRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.declareQueueRequest.queue_name)
  return _s;
}
inline const std::string& declareQueueRequest::_internal_queue_name() const {
  return queue_name_.Get();
}
inline void declareQueueRequest::_internal_set_queue_name(const std::string& value) {
  
  queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* declareQueueRequest::_internal_mutable_queue_name() {
  
  return queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* declareQueueRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:hare_mq.declareQueueRequest.queue_name)
  return queue_name_.Release();
}
inline void declareQueueRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (queue_name_.IsDefault()) {
    queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.declareQueueRequest.queue_name)
}

// bool exclusive = 4;
inline void declareQueueRequest::clear_exclusive() {
  exclusive_ = false;
}
inline bool declareQueueRequest::_internal_exclusive() const {
  return exclusive_;
}
inline bool declareQueueRequest::exclusive() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareQueueRequest.exclusive)
  return _internal_exclusive();
}
inline void declareQueueRequest::_internal_set_exclusive(bool value) {
  
  exclusive_ = value;
}
inline void declareQueueRequest::set_exclusive(bool value) {
  _internal_set_exclusive(value);
  // @@protoc_insertion_point(field_set:hare_mq.declareQueueRequest.exclusive)
}

// bool durable = 5;
inline void declareQueueRequest::clear_durable() {
  durable_ = false;
}
inline bool declareQueueRequest::_internal_durable() const {
  return durable_;
}
inline bool declareQueueRequest::durable() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareQueueRequest.durable)
  return _internal_durable();
}
inline void declareQueueRequest::_internal_set_durable(bool value) {
  
  durable_ = value;
}
inline void declareQueueRequest::set_durable(bool value) {
  _internal_set_durable(value);
  // @@protoc_insertion_point(field_set:hare_mq.declareQueueRequest.durable)
}

// bool auto_delete = 6;
inline void declareQueueRequest::clear_auto_delete() {
  auto_delete_ = false;
}
inline bool declareQueueRequest::_internal_auto_delete() const {
  return auto_delete_;
}
inline bool declareQueueRequest::auto_delete() const {
  // @@protoc_insertion_point(field_get:hare_mq.declareQueueRequest.auto_delete)
  return _internal_auto_delete();
}
inline void declareQueueRequest::_internal_set_auto_delete(bool value) {
  
  auto_delete_ = value;
}
inline void declareQueueRequest::set_auto_delete(bool value) {
  _internal_set_auto_delete(value);
  // @@protoc_insertion_point(field_set:hare_mq.declareQueueRequest.auto_delete)
}

// map<string, string> args = 7;
inline int declareQueueRequest::_internal_args_size() const {
  return args_.size();
}
inline int declareQueueRequest::args_size() const {
  return _internal_args_size();
}
inline void declareQueueRequest::clear_args() {
  args_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
declareQueueRequest::_internal_args() const {
  return args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
declareQueueRequest::args() const {
  // @@protoc_insertion_point(field_map:hare_mq.declareQueueRequest.args)
  return _internal_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
declareQueueRequest::_internal_mutable_args() {
  return args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
declareQueueRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_map:hare_mq.declareQueueRequest.args)
  return _internal_mutable_args();
}

// -------------------------------------------------------------------

// deleteQueueRequest

// string rid = 1;
inline void deleteQueueRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& deleteQueueRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.deleteQueueRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteQueueRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.deleteQueueRequest.rid)
}
inline std::string* deleteQueueRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.deleteQueueRequest.rid)
  return _s;
}
inline const std::string& deleteQueueRequest::_internal_rid() const {
  return rid_.Get();
}
inline void deleteQueueRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.deleteQueueRequest.rid)
  return rid_.Release();
}
inline void deleteQueueRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.deleteQueueRequest.rid)
}

// string cid = 2;
inline void deleteQueueRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& deleteQueueRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.deleteQueueRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteQueueRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.deleteQueueRequest.cid)
}
inline std::string* deleteQueueRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.deleteQueueRequest.cid)
  return _s;
}
inline const std::string& deleteQueueRequest::_internal_cid() const {
  return cid_.Get();
}
inline void deleteQueueRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.deleteQueueRequest.cid)
  return cid_.Release();
}
inline void deleteQueueRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.deleteQueueRequest.cid)
}

// string queue_name = 3;
inline void deleteQueueRequest::clear_queue_name() {
  queue_name_.ClearToEmpty();
}
inline const std::string& deleteQueueRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.deleteQueueRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteQueueRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.deleteQueueRequest.queue_name)
}
inline std::string* deleteQueueRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.deleteQueueRequest.queue_name)
  return _s;
}
inline const std::string& deleteQueueRequest::_internal_queue_name() const {
  return queue_name_.Get();
}
inline void deleteQueueRequest::_internal_set_queue_name(const std::string& value) {
  
  queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::_internal_mutable_queue_name() {
  
  return queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteQueueRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:hare_mq.deleteQueueRequest.queue_name)
  return queue_name_.Release();
}
inline void deleteQueueRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (queue_name_.IsDefault()) {
    queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.deleteQueueRequest.queue_name)
}

// -------------------------------------------------------------------

// bindRequest

// string rid = 1;
inline void bindRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& bindRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.bindRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void bindRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.bindRequest.rid)
}
inline std::string* bindRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.bindRequest.rid)
  return _s;
}
inline const std::string& bindRequest::_internal_rid() const {
  return rid_.Get();
}
inline void bindRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* bindRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* bindRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.bindRequest.rid)
  return rid_.Release();
}
inline void bindRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.bindRequest.rid)
}

// string cid = 2;
inline void bindRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& bindRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.bindRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void bindRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.bindRequest.cid)
}
inline std::string* bindRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.bindRequest.cid)
  return _s;
}
inline const std::string& bindRequest::_internal_cid() const {
  return cid_.Get();
}
inline void bindRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* bindRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* bindRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.bindRequest.cid)
  return cid_.Release();
}
inline void bindRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.bindRequest.cid)
}

// string exchange_name = 3;
inline void bindRequest::clear_exchange_name() {
  exchange_name_.ClearToEmpty();
}
inline const std::string& bindRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.bindRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void bindRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.bindRequest.exchange_name)
}
inline std::string* bindRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.bindRequest.exchange_name)
  return _s;
}
inline const std::string& bindRequest::_internal_exchange_name() const {
  return exchange_name_.Get();
}
inline void bindRequest::_internal_set_exchange_name(const std::string& value) {
  
  exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* bindRequest::_internal_mutable_exchange_name() {
  
  return exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* bindRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:hare_mq.bindRequest.exchange_name)
  return exchange_name_.Release();
}
inline void bindRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (exchange_name_.IsDefault()) {
    exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.bindRequest.exchange_name)
}

// string queue_name = 4;
inline void bindRequest::clear_queue_name() {
  queue_name_.ClearToEmpty();
}
inline const std::string& bindRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.bindRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void bindRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.bindRequest.queue_name)
}
inline std::string* bindRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.bindRequest.queue_name)
  return _s;
}
inline const std::string& bindRequest::_internal_queue_name() const {
  return queue_name_.Get();
}
inline void bindRequest::_internal_set_queue_name(const std::string& value) {
  
  queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* bindRequest::_internal_mutable_queue_name() {
  
  return queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* bindRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:hare_mq.bindRequest.queue_name)
  return queue_name_.Release();
}
inline void bindRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (queue_name_.IsDefault()) {
    queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.bindRequest.queue_name)
}

// string binding_key = 5;
inline void bindRequest::clear_binding_key() {
  binding_key_.ClearToEmpty();
}
inline const std::string& bindRequest::binding_key() const {
  // @@protoc_insertion_point(field_get:hare_mq.bindRequest.binding_key)
  return _internal_binding_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void bindRequest::set_binding_key(ArgT0&& arg0, ArgT... args) {
 
 binding_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.bindRequest.binding_key)
}
inline std::string* bindRequest::mutable_binding_key() {
  std::string* _s = _internal_mutable_binding_key();
  // @@protoc_insertion_point(field_mutable:hare_mq.bindRequest.binding_key)
  return _s;
}
inline const std::string& bindRequest::_internal_binding_key() const {
  return binding_key_.Get();
}
inline void bindRequest::_internal_set_binding_key(const std::string& value) {
  
  binding_key_.Set(value, GetArenaForAllocation());
}
inline std::string* bindRequest::_internal_mutable_binding_key() {
  
  return binding_key_.Mutable(GetArenaForAllocation());
}
inline std::string* bindRequest::release_binding_key() {
  // @@protoc_insertion_point(field_release:hare_mq.bindRequest.binding_key)
  return binding_key_.Release();
}
inline void bindRequest::set_allocated_binding_key(std::string* binding_key) {
  if (binding_key != nullptr) {
    
  } else {
    
  }
  binding_key_.SetAllocated(binding_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (binding_key_.IsDefault()) {
    binding_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.bindRequest.binding_key)
}

// -------------------------------------------------------------------

// unbindRequest

// string rid = 1;
inline void unbindRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& unbindRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.unbindRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void unbindRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.unbindRequest.rid)
}
inline std::string* unbindRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.unbindRequest.rid)
  return _s;
}
inline const std::string& unbindRequest::_internal_rid() const {
  return rid_.Get();
}
inline void unbindRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* unbindRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* unbindRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.unbindRequest.rid)
  return rid_.Release();
}
inline void unbindRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.unbindRequest.rid)
}

// string cid = 2;
inline void unbindRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& unbindRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.unbindRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void unbindRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.unbindRequest.cid)
}
inline std::string* unbindRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.unbindRequest.cid)
  return _s;
}
inline const std::string& unbindRequest::_internal_cid() const {
  return cid_.Get();
}
inline void unbindRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* unbindRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* unbindRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.unbindRequest.cid)
  return cid_.Release();
}
inline void unbindRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.unbindRequest.cid)
}

// string exchange_name = 3;
inline void unbindRequest::clear_exchange_name() {
  exchange_name_.ClearToEmpty();
}
inline const std::string& unbindRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.unbindRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void unbindRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.unbindRequest.exchange_name)
}
inline std::string* unbindRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.unbindRequest.exchange_name)
  return _s;
}
inline const std::string& unbindRequest::_internal_exchange_name() const {
  return exchange_name_.Get();
}
inline void unbindRequest::_internal_set_exchange_name(const std::string& value) {
  
  exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* unbindRequest::_internal_mutable_exchange_name() {
  
  return exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* unbindRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:hare_mq.unbindRequest.exchange_name)
  return exchange_name_.Release();
}
inline void unbindRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (exchange_name_.IsDefault()) {
    exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.unbindRequest.exchange_name)
}

// string queue_name = 4;
inline void unbindRequest::clear_queue_name() {
  queue_name_.ClearToEmpty();
}
inline const std::string& unbindRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.unbindRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void unbindRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.unbindRequest.queue_name)
}
inline std::string* unbindRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.unbindRequest.queue_name)
  return _s;
}
inline const std::string& unbindRequest::_internal_queue_name() const {
  return queue_name_.Get();
}
inline void unbindRequest::_internal_set_queue_name(const std::string& value) {
  
  queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* unbindRequest::_internal_mutable_queue_name() {
  
  return queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* unbindRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:hare_mq.unbindRequest.queue_name)
  return queue_name_.Release();
}
inline void unbindRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (queue_name_.IsDefault()) {
    queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.unbindRequest.queue_name)
}

// -------------------------------------------------------------------

// basicPublishRequest

// string rid = 1;
inline void basicPublishRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& basicPublishRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicPublishRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicPublishRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicPublishRequest.rid)
}
inline std::string* basicPublishRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicPublishRequest.rid)
  return _s;
}
inline const std::string& basicPublishRequest::_internal_rid() const {
  return rid_.Get();
}
inline void basicPublishRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicPublishRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicPublishRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicPublishRequest.rid)
  return rid_.Release();
}
inline void basicPublishRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicPublishRequest.rid)
}

// string cid = 2;
inline void basicPublishRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& basicPublishRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicPublishRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicPublishRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicPublishRequest.cid)
}
inline std::string* basicPublishRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicPublishRequest.cid)
  return _s;
}
inline const std::string& basicPublishRequest::_internal_cid() const {
  return cid_.Get();
}
inline void basicPublishRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicPublishRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicPublishRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicPublishRequest.cid)
  return cid_.Release();
}
inline void basicPublishRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicPublishRequest.cid)
}

// string exchange_name = 3;
inline void basicPublishRequest::clear_exchange_name() {
  exchange_name_.ClearToEmpty();
}
inline const std::string& basicPublishRequest::exchange_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicPublishRequest.exchange_name)
  return _internal_exchange_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicPublishRequest::set_exchange_name(ArgT0&& arg0, ArgT... args) {
 
 exchange_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicPublishRequest.exchange_name)
}
inline std::string* basicPublishRequest::mutable_exchange_name() {
  std::string* _s = _internal_mutable_exchange_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicPublishRequest.exchange_name)
  return _s;
}
inline const std::string& basicPublishRequest::_internal_exchange_name() const {
  return exchange_name_.Get();
}
inline void basicPublishRequest::_internal_set_exchange_name(const std::string& value) {
  
  exchange_name_.Set(value, GetArenaForAllocation());
}
inline std::string* basicPublishRequest::_internal_mutable_exchange_name() {
  
  return exchange_name_.Mutable(GetArenaForAllocation());
}
inline std::string* basicPublishRequest::release_exchange_name() {
  // @@protoc_insertion_point(field_release:hare_mq.basicPublishRequest.exchange_name)
  return exchange_name_.Release();
}
inline void basicPublishRequest::set_allocated_exchange_name(std::string* exchange_name) {
  if (exchange_name != nullptr) {
    
  } else {
    
  }
  exchange_name_.SetAllocated(exchange_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (exchange_name_.IsDefault()) {
    exchange_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicPublishRequest.exchange_name)
}

// string body = 4;
inline void basicPublishRequest::clear_body() {
  body_.ClearToEmpty();
}
inline const std::string& basicPublishRequest::body() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicPublishRequest.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicPublishRequest::set_body(ArgT0&& arg0, ArgT... args) {
 
 body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicPublishRequest.body)
}
inline std::string* basicPublishRequest::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicPublishRequest.body)
  return _s;
}
inline const std::string& basicPublishRequest::_internal_body() const {
  return body_.Get();
}
inline void basicPublishRequest::_internal_set_body(const std::string& value) {
  
  body_.Set(value, GetArenaForAllocation());
}
inline std::string* basicPublishRequest::_internal_mutable_body() {
  
  return body_.Mutable(GetArenaForAllocation());
}
inline std::string* basicPublishRequest::release_body() {
  // @@protoc_insertion_point(field_release:hare_mq.basicPublishRequest.body)
  return body_.Release();
}
inline void basicPublishRequest::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault()) {
    body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicPublishRequest.body)
}

// .hare_mq.BasicProperties properties = 5;
inline bool basicPublishRequest::_internal_has_properties() const {
  return this != internal_default_instance() && properties_ != nullptr;
}
inline bool basicPublishRequest::has_properties() const {
  return _internal_has_properties();
}
inline const ::hare_mq::BasicProperties& basicPublishRequest::_internal_properties() const {
  const ::hare_mq::BasicProperties* p = properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::hare_mq::BasicProperties&>(
      ::hare_mq::_BasicProperties_default_instance_);
}
inline const ::hare_mq::BasicProperties& basicPublishRequest::properties() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicPublishRequest.properties)
  return _internal_properties();
}
inline void basicPublishRequest::unsafe_arena_set_allocated_properties(
    ::hare_mq::BasicProperties* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties_);
  }
  properties_ = properties;
  if (properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hare_mq.basicPublishRequest.properties)
}
inline ::hare_mq::BasicProperties* basicPublishRequest::release_properties() {
  
  ::hare_mq::BasicProperties* temp = properties_;
  properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hare_mq::BasicProperties* basicPublishRequest::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:hare_mq.basicPublishRequest.properties)
  
  ::hare_mq::BasicProperties* temp = properties_;
  properties_ = nullptr;
  return temp;
}
inline ::hare_mq::BasicProperties* basicPublishRequest::_internal_mutable_properties() {
  
  if (properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::hare_mq::BasicProperties>(GetArenaForAllocation());
    properties_ = p;
  }
  return properties_;
}
inline ::hare_mq::BasicProperties* basicPublishRequest::mutable_properties() {
  ::hare_mq::BasicProperties* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicPublishRequest.properties)
  return _msg;
}
inline void basicPublishRequest::set_allocated_properties(::hare_mq::BasicProperties* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties_);
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties));
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    
  } else {
    
  }
  properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicPublishRequest.properties)
}

// -------------------------------------------------------------------

// basicAckRequest

// string rid = 1;
inline void basicAckRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& basicAckRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicAckRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicAckRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicAckRequest.rid)
}
inline std::string* basicAckRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicAckRequest.rid)
  return _s;
}
inline const std::string& basicAckRequest::_internal_rid() const {
  return rid_.Get();
}
inline void basicAckRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicAckRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicAckRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicAckRequest.rid)
  return rid_.Release();
}
inline void basicAckRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicAckRequest.rid)
}

// string cid = 2;
inline void basicAckRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& basicAckRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicAckRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicAckRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicAckRequest.cid)
}
inline std::string* basicAckRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicAckRequest.cid)
  return _s;
}
inline const std::string& basicAckRequest::_internal_cid() const {
  return cid_.Get();
}
inline void basicAckRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicAckRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicAckRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicAckRequest.cid)
  return cid_.Release();
}
inline void basicAckRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicAckRequest.cid)
}

// string queue_name = 3;
inline void basicAckRequest::clear_queue_name() {
  queue_name_.ClearToEmpty();
}
inline const std::string& basicAckRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicAckRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicAckRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicAckRequest.queue_name)
}
inline std::string* basicAckRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicAckRequest.queue_name)
  return _s;
}
inline const std::string& basicAckRequest::_internal_queue_name() const {
  return queue_name_.Get();
}
inline void basicAckRequest::_internal_set_queue_name(const std::string& value) {
  
  queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* basicAckRequest::_internal_mutable_queue_name() {
  
  return queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* basicAckRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:hare_mq.basicAckRequest.queue_name)
  return queue_name_.Release();
}
inline void basicAckRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (queue_name_.IsDefault()) {
    queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicAckRequest.queue_name)
}

// string message_id = 4;
inline void basicAckRequest::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& basicAckRequest::message_id() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicAckRequest.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicAckRequest::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicAckRequest.message_id)
}
inline std::string* basicAckRequest::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicAckRequest.message_id)
  return _s;
}
inline const std::string& basicAckRequest::_internal_message_id() const {
  return message_id_.Get();
}
inline void basicAckRequest::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* basicAckRequest::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* basicAckRequest::release_message_id() {
  // @@protoc_insertion_point(field_release:hare_mq.basicAckRequest.message_id)
  return message_id_.Release();
}
inline void basicAckRequest::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicAckRequest.message_id)
}

// -------------------------------------------------------------------

// basicConsumeRequest

// string rid = 1;
inline void basicConsumeRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& basicConsumeRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicConsumeRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicConsumeRequest.rid)
}
inline std::string* basicConsumeRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicConsumeRequest.rid)
  return _s;
}
inline const std::string& basicConsumeRequest::_internal_rid() const {
  return rid_.Get();
}
inline void basicConsumeRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicConsumeRequest.rid)
  return rid_.Release();
}
inline void basicConsumeRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicConsumeRequest.rid)
}

// string cid = 2;
inline void basicConsumeRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& basicConsumeRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicConsumeRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicConsumeRequest.cid)
}
inline std::string* basicConsumeRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicConsumeRequest.cid)
  return _s;
}
inline const std::string& basicConsumeRequest::_internal_cid() const {
  return cid_.Get();
}
inline void basicConsumeRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicConsumeRequest.cid)
  return cid_.Release();
}
inline void basicConsumeRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicConsumeRequest.cid)
}

// string consumer_tag = 3;
inline void basicConsumeRequest::clear_consumer_tag() {
  consumer_tag_.ClearToEmpty();
}
inline const std::string& basicConsumeRequest::consumer_tag() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicConsumeRequest.consumer_tag)
  return _internal_consumer_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeRequest::set_consumer_tag(ArgT0&& arg0, ArgT... args) {
 
 consumer_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicConsumeRequest.consumer_tag)
}
inline std::string* basicConsumeRequest::mutable_consumer_tag() {
  std::string* _s = _internal_mutable_consumer_tag();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicConsumeRequest.consumer_tag)
  return _s;
}
inline const std::string& basicConsumeRequest::_internal_consumer_tag() const {
  return consumer_tag_.Get();
}
inline void basicConsumeRequest::_internal_set_consumer_tag(const std::string& value) {
  
  consumer_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::_internal_mutable_consumer_tag() {
  
  return consumer_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::release_consumer_tag() {
  // @@protoc_insertion_point(field_release:hare_mq.basicConsumeRequest.consumer_tag)
  return consumer_tag_.Release();
}
inline void basicConsumeRequest::set_allocated_consumer_tag(std::string* consumer_tag) {
  if (consumer_tag != nullptr) {
    
  } else {
    
  }
  consumer_tag_.SetAllocated(consumer_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (consumer_tag_.IsDefault()) {
    consumer_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicConsumeRequest.consumer_tag)
}

// string queue_name = 4;
inline void basicConsumeRequest::clear_queue_name() {
  queue_name_.ClearToEmpty();
}
inline const std::string& basicConsumeRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicConsumeRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicConsumeRequest.queue_name)
}
inline std::string* basicConsumeRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicConsumeRequest.queue_name)
  return _s;
}
inline const std::string& basicConsumeRequest::_internal_queue_name() const {
  return queue_name_.Get();
}
inline void basicConsumeRequest::_internal_set_queue_name(const std::string& value) {
  
  queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::_internal_mutable_queue_name() {
  
  return queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:hare_mq.basicConsumeRequest.queue_name)
  return queue_name_.Release();
}
inline void basicConsumeRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (queue_name_.IsDefault()) {
    queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicConsumeRequest.queue_name)
}

// bool auto_ack = 5;
inline void basicConsumeRequest::clear_auto_ack() {
  auto_ack_ = false;
}
inline bool basicConsumeRequest::_internal_auto_ack() const {
  return auto_ack_;
}
inline bool basicConsumeRequest::auto_ack() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicConsumeRequest.auto_ack)
  return _internal_auto_ack();
}
inline void basicConsumeRequest::_internal_set_auto_ack(bool value) {
  
  auto_ack_ = value;
}
inline void basicConsumeRequest::set_auto_ack(bool value) {
  _internal_set_auto_ack(value);
  // @@protoc_insertion_point(field_set:hare_mq.basicConsumeRequest.auto_ack)
}

// -------------------------------------------------------------------

// basicCancelRequest

// string rid = 1;
inline void basicCancelRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& basicCancelRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicCancelRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCancelRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicCancelRequest.rid)
}
inline std::string* basicCancelRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicCancelRequest.rid)
  return _s;
}
inline const std::string& basicCancelRequest::_internal_rid() const {
  return rid_.Get();
}
inline void basicCancelRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCancelRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCancelRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicCancelRequest.rid)
  return rid_.Release();
}
inline void basicCancelRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicCancelRequest.rid)
}

// string cid = 2;
inline void basicCancelRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& basicCancelRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicCancelRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCancelRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicCancelRequest.cid)
}
inline std::string* basicCancelRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicCancelRequest.cid)
  return _s;
}
inline const std::string& basicCancelRequest::_internal_cid() const {
  return cid_.Get();
}
inline void basicCancelRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCancelRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCancelRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicCancelRequest.cid)
  return cid_.Release();
}
inline void basicCancelRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicCancelRequest.cid)
}

// string consumer_tag = 3;
inline void basicCancelRequest::clear_consumer_tag() {
  consumer_tag_.ClearToEmpty();
}
inline const std::string& basicCancelRequest::consumer_tag() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicCancelRequest.consumer_tag)
  return _internal_consumer_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCancelRequest::set_consumer_tag(ArgT0&& arg0, ArgT... args) {
 
 consumer_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicCancelRequest.consumer_tag)
}
inline std::string* basicCancelRequest::mutable_consumer_tag() {
  std::string* _s = _internal_mutable_consumer_tag();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicCancelRequest.consumer_tag)
  return _s;
}
inline const std::string& basicCancelRequest::_internal_consumer_tag() const {
  return consumer_tag_.Get();
}
inline void basicCancelRequest::_internal_set_consumer_tag(const std::string& value) {
  
  consumer_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCancelRequest::_internal_mutable_consumer_tag() {
  
  return consumer_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCancelRequest::release_consumer_tag() {
  // @@protoc_insertion_point(field_release:hare_mq.basicCancelRequest.consumer_tag)
  return consumer_tag_.Release();
}
inline void basicCancelRequest::set_allocated_consumer_tag(std::string* consumer_tag) {
  if (consumer_tag != nullptr) {
    
  } else {
    
  }
  consumer_tag_.SetAllocated(consumer_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (consumer_tag_.IsDefault()) {
    consumer_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicCancelRequest.consumer_tag)
}

// string queue_name = 4;
inline void basicCancelRequest::clear_queue_name() {
  queue_name_.ClearToEmpty();
}
inline const std::string& basicCancelRequest::queue_name() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicCancelRequest.queue_name)
  return _internal_queue_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCancelRequest::set_queue_name(ArgT0&& arg0, ArgT... args) {
 
 queue_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicCancelRequest.queue_name)
}
inline std::string* basicCancelRequest::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicCancelRequest.queue_name)
  return _s;
}
inline const std::string& basicCancelRequest::_internal_queue_name() const {
  return queue_name_.Get();
}
inline void basicCancelRequest::_internal_set_queue_name(const std::string& value) {
  
  queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCancelRequest::_internal_mutable_queue_name() {
  
  return queue_name_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCancelRequest::release_queue_name() {
  // @@protoc_insertion_point(field_release:hare_mq.basicCancelRequest.queue_name)
  return queue_name_.Release();
}
inline void basicCancelRequest::set_allocated_queue_name(std::string* queue_name) {
  if (queue_name != nullptr) {
    
  } else {
    
  }
  queue_name_.SetAllocated(queue_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (queue_name_.IsDefault()) {
    queue_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicCancelRequest.queue_name)
}

// -------------------------------------------------------------------

// basicConsumeResponse

// string cid = 1;
inline void basicConsumeResponse::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& basicConsumeResponse::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicConsumeResponse.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeResponse::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicConsumeResponse.cid)
}
inline std::string* basicConsumeResponse::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicConsumeResponse.cid)
  return _s;
}
inline const std::string& basicConsumeResponse::_internal_cid() const {
  return cid_.Get();
}
inline void basicConsumeResponse::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicConsumeResponse.cid)
  return cid_.Release();
}
inline void basicConsumeResponse::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicConsumeResponse.cid)
}

// string consumer_tag = 2;
inline void basicConsumeResponse::clear_consumer_tag() {
  consumer_tag_.ClearToEmpty();
}
inline const std::string& basicConsumeResponse::consumer_tag() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicConsumeResponse.consumer_tag)
  return _internal_consumer_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeResponse::set_consumer_tag(ArgT0&& arg0, ArgT... args) {
 
 consumer_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicConsumeResponse.consumer_tag)
}
inline std::string* basicConsumeResponse::mutable_consumer_tag() {
  std::string* _s = _internal_mutable_consumer_tag();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicConsumeResponse.consumer_tag)
  return _s;
}
inline const std::string& basicConsumeResponse::_internal_consumer_tag() const {
  return consumer_tag_.Get();
}
inline void basicConsumeResponse::_internal_set_consumer_tag(const std::string& value) {
  
  consumer_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::_internal_mutable_consumer_tag() {
  
  return consumer_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::release_consumer_tag() {
  // @@protoc_insertion_point(field_release:hare_mq.basicConsumeResponse.consumer_tag)
  return consumer_tag_.Release();
}
inline void basicConsumeResponse::set_allocated_consumer_tag(std::string* consumer_tag) {
  if (consumer_tag != nullptr) {
    
  } else {
    
  }
  consumer_tag_.SetAllocated(consumer_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (consumer_tag_.IsDefault()) {
    consumer_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicConsumeResponse.consumer_tag)
}

// string body = 3;
inline void basicConsumeResponse::clear_body() {
  body_.ClearToEmpty();
}
inline const std::string& basicConsumeResponse::body() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicConsumeResponse.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicConsumeResponse::set_body(ArgT0&& arg0, ArgT... args) {
 
 body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicConsumeResponse.body)
}
inline std::string* basicConsumeResponse::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicConsumeResponse.body)
  return _s;
}
inline const std::string& basicConsumeResponse::_internal_body() const {
  return body_.Get();
}
inline void basicConsumeResponse::_internal_set_body(const std::string& value) {
  
  body_.Set(value, GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::_internal_mutable_body() {
  
  return body_.Mutable(GetArenaForAllocation());
}
inline std::string* basicConsumeResponse::release_body() {
  // @@protoc_insertion_point(field_release:hare_mq.basicConsumeResponse.body)
  return body_.Release();
}
inline void basicConsumeResponse::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault()) {
    body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicConsumeResponse.body)
}

// .hare_mq.BasicProperties properties = 4;
inline bool basicConsumeResponse::_internal_has_properties() const {
  return this != internal_default_instance() && properties_ != nullptr;
}
inline bool basicConsumeResponse::has_properties() const {
  return _internal_has_properties();
}
inline const ::hare_mq::BasicProperties& basicConsumeResponse::_internal_properties() const {
  const ::hare_mq::BasicProperties* p = properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::hare_mq::BasicProperties&>(
      ::hare_mq::_BasicProperties_default_instance_);
}
inline const ::hare_mq::BasicProperties& basicConsumeResponse::properties() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicConsumeResponse.properties)
  return _internal_properties();
}
inline void basicConsumeResponse::unsafe_arena_set_allocated_properties(
    ::hare_mq::BasicProperties* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties_);
  }
  properties_ = properties;
  if (properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hare_mq.basicConsumeResponse.properties)
}
inline ::hare_mq::BasicProperties* basicConsumeResponse::release_properties() {
  
  ::hare_mq::BasicProperties* temp = properties_;
  properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hare_mq::BasicProperties* basicConsumeResponse::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:hare_mq.basicConsumeResponse.properties)
  
  ::hare_mq::BasicProperties* temp = properties_;
  properties_ = nullptr;
  return temp;
}
inline ::hare_mq::BasicProperties* basicConsumeResponse::_internal_mutable_properties() {
  
  if (properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::hare_mq::BasicProperties>(GetArenaForAllocation());
    properties_ = p;
  }
  return properties_;
}
inline ::hare_mq::BasicProperties* basicConsumeResponse::mutable_properties() {
  ::hare_mq::BasicProperties* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicConsumeResponse.properties)
  return _msg;
}
inline void basicConsumeResponse::set_allocated_properties(::hare_mq::BasicProperties* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties_);
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties));
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    
  } else {
    
  }
  properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicConsumeResponse.properties)
}

// -------------------------------------------------------------------

// basicCommonResponse

// string rid = 1;
inline void basicCommonResponse::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& basicCommonResponse::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicCommonResponse.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCommonResponse::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicCommonResponse.rid)
}
inline std::string* basicCommonResponse::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicCommonResponse.rid)
  return _s;
}
inline const std::string& basicCommonResponse::_internal_rid() const {
  return rid_.Get();
}
inline void basicCommonResponse::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCommonResponse::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCommonResponse::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicCommonResponse.rid)
  return rid_.Release();
}
inline void basicCommonResponse::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicCommonResponse.rid)
}

// string cid = 2;
inline void basicCommonResponse::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& basicCommonResponse::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicCommonResponse.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicCommonResponse::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicCommonResponse.cid)
}
inline std::string* basicCommonResponse::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicCommonResponse.cid)
  return _s;
}
inline const std::string& basicCommonResponse::_internal_cid() const {
  return cid_.Get();
}
inline void basicCommonResponse::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicCommonResponse::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicCommonResponse::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicCommonResponse.cid)
  return cid_.Release();
}
inline void basicCommonResponse::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicCommonResponse.cid)
}

// bool ok = 3;
inline void basicCommonResponse::clear_ok() {
  ok_ = false;
}
inline bool basicCommonResponse::_internal_ok() const {
  return ok_;
}
inline bool basicCommonResponse::ok() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicCommonResponse.ok)
  return _internal_ok();
}
inline void basicCommonResponse::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void basicCommonResponse::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:hare_mq.basicCommonResponse.ok)
}

// -------------------------------------------------------------------

// basicQueryRequest

// string rid = 1;
inline void basicQueryRequest::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& basicQueryRequest::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicQueryRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicQueryRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicQueryRequest.rid)
}
inline std::string* basicQueryRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicQueryRequest.rid)
  return _s;
}
inline const std::string& basicQueryRequest::_internal_rid() const {
  return rid_.Get();
}
inline void basicQueryRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicQueryRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicQueryRequest::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicQueryRequest.rid)
  return rid_.Release();
}
inline void basicQueryRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicQueryRequest.rid)
}

// string cid = 2;
inline void basicQueryRequest::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& basicQueryRequest::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicQueryRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicQueryRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicQueryRequest.cid)
}
inline std::string* basicQueryRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicQueryRequest.cid)
  return _s;
}
inline const std::string& basicQueryRequest::_internal_cid() const {
  return cid_.Get();
}
inline void basicQueryRequest::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicQueryRequest::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicQueryRequest::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicQueryRequest.cid)
  return cid_.Release();
}
inline void basicQueryRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicQueryRequest.cid)
}

// -------------------------------------------------------------------

// basicQueryResponse

// string rid = 1;
inline void basicQueryResponse::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& basicQueryResponse::rid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicQueryResponse.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicQueryResponse::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicQueryResponse.rid)
}
inline std::string* basicQueryResponse::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicQueryResponse.rid)
  return _s;
}
inline const std::string& basicQueryResponse::_internal_rid() const {
  return rid_.Get();
}
inline void basicQueryResponse::_internal_set_rid(const std::string& value) {
  
  rid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicQueryResponse::_internal_mutable_rid() {
  
  return rid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicQueryResponse::release_rid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicQueryResponse.rid)
  return rid_.Release();
}
inline void basicQueryResponse::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault()) {
    rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicQueryResponse.rid)
}

// string cid = 2;
inline void basicQueryResponse::clear_cid() {
  cid_.ClearToEmpty();
}
inline const std::string& basicQueryResponse::cid() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicQueryResponse.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicQueryResponse::set_cid(ArgT0&& arg0, ArgT... args) {
 
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicQueryResponse.cid)
}
inline std::string* basicQueryResponse::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicQueryResponse.cid)
  return _s;
}
inline const std::string& basicQueryResponse::_internal_cid() const {
  return cid_.Get();
}
inline void basicQueryResponse::_internal_set_cid(const std::string& value) {
  
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* basicQueryResponse::_internal_mutable_cid() {
  
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* basicQueryResponse::release_cid() {
  // @@protoc_insertion_point(field_release:hare_mq.basicQueryResponse.cid)
  return cid_.Release();
}
inline void basicQueryResponse::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicQueryResponse.cid)
}

// string body = 3;
inline void basicQueryResponse::clear_body() {
  body_.ClearToEmpty();
}
inline const std::string& basicQueryResponse::body() const {
  // @@protoc_insertion_point(field_get:hare_mq.basicQueryResponse.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void basicQueryResponse::set_body(ArgT0&& arg0, ArgT... args) {
 
 body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hare_mq.basicQueryResponse.body)
}
inline std::string* basicQueryResponse::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:hare_mq.basicQueryResponse.body)
  return _s;
}
inline const std::string& basicQueryResponse::_internal_body() const {
  return body_.Get();
}
inline void basicQueryResponse::_internal_set_body(const std::string& value) {
  
  body_.Set(value, GetArenaForAllocation());
}
inline std::string* basicQueryResponse::_internal_mutable_body() {
  
  return body_.Mutable(GetArenaForAllocation());
}
inline std::string* basicQueryResponse::release_body() {
  // @@protoc_insertion_point(field_release:hare_mq.basicQueryResponse.body)
  return body_.Release();
}
inline void basicQueryResponse::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault()) {
    body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hare_mq.basicQueryResponse.body)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hare_mq

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
